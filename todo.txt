
/*
 - Generate a full set of tests (KATs?)
 - Figure out zfec's file encoding layout
 - Write a zfec-interoperable encoder/decoder program
 - Write benchmark suite across range of parameters
    - Generating a gnuplot file for comparisons
 - Convert to C++ class(es) (using zfec's Python API as design base?)
 - Profile, optimize
 - x86-64 inline asm?

Random ideas:

Decoder should be a streaming interface, you feed it a packet, a
data,index tuple, and it tells you how many more are needed for
sucessful reconstruction.

Encoder doing just memcpy for k/n blocks is pretty weak, no reason
for that! Also, should generate all FEC blocks at once (?!?),
 maybe offers parallelism and/or better unrolling
*/

namespace fecpp {

typedef unsigned char byte;

class encoder
   {
   public:
      encoder(byte k, byte n);

      byte k() const;
      byte n() const;

      size_t fec_bytes(size_t input_size) const;

      void encode(const byte input[], size_t input_size, byte fec[]) const;
   };

class decoder
   {
   public:
      decoder();

      bool message_restored() const;
      void decode(const byte input[], size_t input_size);
   };

}
